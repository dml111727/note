### 简单工厂

就是把普通的new 对象放到工厂中进行创建，通过传参数获取对应的对象。

缺点：工厂类的职责相对过重，不易于扩展过于复杂的产品结构。

举例：创建Java工程师、Python工程师。

#### IT员工接口

```
package com.dml.pattern.factory;

/**
 * @author dml111727
 * @version 1.0
 * @Date 2021/6/30 0030 23:28
 * @describe IT员工
 */
public interface ITStaff {

    void writeCode();
}

```



#### java工程师类

```
package com.dml.pattern.factory;

/**
 * @author dml111727
 * @version 1.0
 * @Date 2021/6/30 0030 23:30
 * @describe java工程师
 */
public class JavaStaff implements ITStaff {

    @Override
    public void writeCode() {
        System.out.println("写java代码");
    }
}

```

#### python工程师类

```
package com.dml.pattern.factory;

/**
 * @author dml111727
 * @version 1.0
 * @Date 2021/6/30 0030 23:39
 * @describe python工程师
 */
public class PythonStaff implements ITStaff {
    @Override
    public void writeCode() {
        System.out.println("写python代码");
    }
}

```

#### 简单工厂

```
package com.dml.pattern.factory.simplefactory;

import com.dml.pattern.factory.ITStaff;

/**
 * @author dml111727
 * @version 1.0
 * @Date 2021/6/30 0030 23:41
 * @describe IT公司
 */
public class ITFactory {
    public ITStaff create(Class<? extends ITStaff> clazz) {
        if (null != clazz) {
            try {
                return clazz.newInstance();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return null;
    }
}
```

#### 测试

```
package com.dml.pattern.factory.simplefactory;

import com.dml.pattern.factory.ITStaff;
import com.dml.pattern.factory.JavaStaff;

/**
 * @author dml111727
 * @version 1.0
 * @Date 2021/6/30 0030 23:40
 * @describe
 */
public class Test {
    public static void main(String[] args) {
        ITFactory itFactory = new ITFactory();
        // 创建java工程师对象
        ITStaff itStaff = itFactory.create(JavaStaff.class);
        itStaff.writeCode();
    }
}
```



### 工厂方法

由于简单工厂需要传参获取对象，不便于创建，容易出错，且产品多了，创建逻辑混乱，修改难度加大。

工厂方法：定义一个创建对象的接口，但让实现这个 接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行。在工厂方法 模式中用户只需要关心所需产品对应的工厂，无须关心创建细节，而且加入新的产品符 合开闭原则

工厂方法适用于以下场景： 

​	1、创建对象需要大量重复的代码。

​	2、客户端（应用层）不依赖于产品类实例如何被创建、实现等细节。 

​	3、一个类通过其子类来指定创建哪个对象。 

工厂方法也有缺点： 

​	1、类的个数容易过多，增加复杂度。 

​	2、增加了系统的抽象性和理解难度。

举例：创建Java工程师、Python工程师。

#### IT员工工厂接口

```
package com.dml.pattern.factory.factorymethod;

import com.dml.pattern.factory.ITStaff;

/**
 * @author dml111727
 * @version 1.0
 * @Date 2021/6/30 0030 23:49
 * @describe IT员工工厂
 */
public interface ITStaffFactory {
    /**
     * 创建员工
     * @return
     */
    ITStaff createStaff();
}

```

#### java工程师工厂

```
package com.dml.pattern.factory.factorymethod;

import com.dml.pattern.factory.ITStaff;
import com.dml.pattern.factory.JavaStaff;

/**
 * @author dml111727
 * @version 1.0
 * @Date 2021/6/30 0030 23:50
 * @describe
 */
public class JavaStaffFactory implements ITStaffFactory {
    @Override
    public ITStaff createStaff() {
        return new JavaStaff();
    }
}
```

#### python工程师工厂

```
package com.dml.pattern.factory.factorymethod;

import com.dml.pattern.factory.ITStaff;
import com.dml.pattern.factory.PythonStaff;

/**
 * @author dml111727
 * @version 1.0
 * @Date 2021/6/30 0030 23:51
 * @describe
 */
public class PythonStaffFactory implements ITStaffFactory {
    @Override
    public ITStaff createStaff() {
        return new PythonStaff();
    }
}
```

#### 测试

```
package com.dml.pattern.factory.factorymethod;

import com.dml.pattern.factory.ITStaff;

/**
 * @author dml111727
 * @version 1.0
 * @Date 2021/6/30 0030 23:51
 * @describe
 */
public class Test {
    public static void main(String[] args) {
        ITStaffFactory itStaffFactory = new JavaStaffFactory();
        ITStaff staff = itStaffFactory.createStaff();
        staff.writeCode();
    }
}
```

### 抽象工厂

抽象工厂：提供一个创建一系列相关或相互依赖对象的接口，无须指定他们具体的类

缺点：

​		1、规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂 的接口。

​	 	2、增加了系统的抽象性和理解难度

举例：IT公司招聘任何方向的工厂师，技能需求：写文档、开发项目、运维、写需求、分析需求等。

#### 文档接口

```
package com.dml.pattern.factory.abstractfactory;

/**
 * @author dml111727
 * @version 1.0
 * @Date 2021/6/30 0030 23:58
 * @describe
 */
public interface Document {
    void writeDocument();
}
```

#### java文档

```
package com.dml.pattern.factory.abstractfactory;

/**
 * @author dml111727
 * @version 1.0
 * @Date 2021/7/1 0001 0:01
 * @describe
 */
public class JavaDocument implements Document {

    @Override
    public void writeDocument() {
        System.out.println("写java文档");
    }
}
```

#### 项目接口

```
package com.dml.pattern.factory.abstractfactory;

/**
 * @author dml111727
 * @version 1.0
 * @Date 2021/6/30 0030 23:57
 * @describe
 */
public interface Project {
    void writeCode();
}
```

#### java项目

```
package com.dml.pattern.factory.abstractfactory;

/**
 * @author dml111727
 * @version 1.0
 * @Date 2021/7/1 0001 0:01
 * @describe
 */
public class JavaProject implements Project {
    @Override
    public void writeCode() {
        System.out.println("写java代码");
    }
}
```

#### 抽象工厂

```
package com.dml.pattern.factory.abstractfactory;


/**
 * @author dml111727
 * @version 1.0
 * @Date 2021/6/30 0030 23:55
 * @describe 抽象工厂，每个员工应该要的技能
 */
public abstract class AbstracStaffFactory {
    /**
     * 项目
     */
    abstract Project createProject();

    /**
     * 文档
     */
    abstract Document createDocument();
}
```

#### java工程师工厂

```
package com.dml.pattern.factory.abstractfactory;

/**
 * @author dml111727
 * @version 1.0
 * @Date 2021/7/1 0001 0:00
 * @describe
 */
public class JavaStaffFactory extends AbstracStaffFactory {
    @Override
    Project createProject() {
        return new JavaProject();
    }

    @Override
    Document createDocument() {
        return new JavaDocument();
    }
}
```

#### 测试

```
package com.dml.pattern.factory.abstractfactory;

/**
 * @author dml111727
 * @version 1.0
 * @Date 2021/7/1 0001 0:03
 * @describe
 */
public class Test {
    public static void main(String[] args) {
        JavaStaffFactory javaStaffFactory = new JavaStaffFactory();
        javaStaffFactory.createDocument().writeDocument();
        javaStaffFactory.createProject().writeCode();
    }
}
```

