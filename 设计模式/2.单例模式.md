## 单例模式

确保任何情况下都绝对只有一个实例

目的：为了使资源能够共享，只需要赋值或者初始化一次

应用场景：IOC容器、配置信息等 

提供获取实例方法、私有构造、保证线程安全、延迟加载、防止序列化和反序列化破坏单例、防御反射攻击单例

### 饿汉式

在系统启动时就会加载，不管用不用的到；

缺点：浪费内容空间

#### 实现

##### 方式一：静态成员

```java
package com.dml.pattern.singleton.hungry;

/**
 * @author dml111727
 * @version 1.0
 * @Date 2021/7/6 0006 23:46
 * @describe
 */
public class HungrySingleton {

    private HungrySingleton() {
        if (null != instance) {
            throw new RuntimeException("不允许创建两个对象");
        }
    }

    private static final HungrySingleton instance = new HungrySingleton();


    public static HungrySingleton getInstance() {
        return instance;
    }
}


```



##### 方式二：静态代码块

```java
package com.dml.pattern.singleton.hungry;

/**
 * @author dml111727
 * @version 1.0
 * @Date 2021/7/6 0006 23:46
 * @describe
 */
public class HungryStaticSingleton {

    private HungryStaticSingleton() {
        if (null != instance) {
            throw new RuntimeException("不允许创建两个对象");
        }
    }

    private static final HungryStaticSingleton instance;

    static {
        instance = new HungryStaticSingleton();
    }

    public static HungryStaticSingleton getInstance() {
        return instance;
    }
}


```



### 懒汉式

被外部调用时才初始化

#### 实现

##### 方式一：静态方法锁

```java
package com.dml.pattern.singleton.lazy;

/**
 * @author dml111727
 * @version 1.0
 * @Date 2021/7/6 0006 23:51
 * @describe 静态方法锁
 */
public class LazyMethodLockSingleton {
    private LazyMethodLockSingleton() {
        if (null != instance) {
            throw new RuntimeException("不允许创建两个对象");
        }
    }

    private static LazyMethodLockSingleton instance = null;

    public synchronized static LazyMethodLockSingleton getInstance() {

        if (null == instance) {
            instance = new LazyMethodLockSingleton();
        }

        return instance;
    }

}

```

##### 方式二：双重锁(类锁、 指令重排volatile)  

```java
package com.dml.pattern.singleton.lazy;

/**
 * @author dml111727
 * @version 1.0
 * @Date 2021/7/6 0006 23:51
 * @describe 双重锁
 */
public class LazyDoubleLockSingleton {
    private LazyDoubleLockSingleton() {
        if (null != instance) {
            throw new RuntimeException("不允许创建两个对象");
        }
    }

    private volatile static LazyDoubleLockSingleton instance = null;

    public static LazyDoubleLockSingleton getInstance() {

        if (null == instance) {
            synchronized (LazyDoubleLockSingleton.class) {
                if (null == instance) {
                    instance = new LazyDoubleLockSingleton();
                }
            }
        }

        return instance;
    }

}

```

##### 方式三：静态内部类(性能最优)

内部类只有在外部调用时才会加载(内部类执行逻辑)

```java
package com.dml.pattern.singleton.lazy;

/**
 * @author dml111727
 * @version 1.0
 * @Date 2021/7/6 0006 23:51
 * @describe 双重锁
 */
public class LazyInnerClassSingleton {
    private LazyInnerClassSingleton() {
        if (null != Singleton.INSTANCE) {
            throw new RuntimeException("不允许创建两个对象");
        }
    }

    public static LazyInnerClassSingleton getInstance() {
        return Singleton.INSTANCE;
    }


    private static class Singleton {
        private static final LazyInnerClassSingleton INSTANCE = new LazyInnerClassSingleton();
    }
}

```







### 注册式

#### 枚举式单例

JDK层面就位枚举不被序列化和反射破坏来保驾护航

```java
package com.dml.pattern.singleton.register;

/**
 * @author dml111727
 * @version 1.0
 * @Date 2021/7/7 0007 21:21
 * @describe 枚举式单例
 */
public enum EnumSingleton {

    INSTANCE;

    public static EnumSingleton getInstance() {
        return INSTANCE;
    }


}
```



#### 容器式单例(spring)

```java
package com.dml.pattern.singleton.register;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * @author dml111727
 * @version 1.0
 * @Date 2021/7/7 0007 21:24
 * @describe 容器式单例
 */
public class ContainerSingleton {
    private ContainerSingleton() {
    }

    // 容器，存放对象
    private static Map<String, Object> ioc = new ConcurrentHashMap<>();


    public static Object getInstance(String className) {
        synchronized (ioc) {
            if (!ioc.containsKey(className)) {

                try {
                    Class<?> aClass = Class.forName(className);
                    Object o = aClass.newInstance();
                    ioc.put(className, o);
                    return o;
                } catch (Exception e) {
                    e.printStackTrace();
                    return null;
                }
            } else {
                return ioc.get(className);
            }
        }

    }
}

```

测试

并发类

```java
package com.dml.pattern.singleton.test;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Semaphore;


public class ConcurrentExecutor {
    /**
     * @param runHandler
     * @param executeCount 发起请求总数
     * @param concurrentCount 同时并发执行的线程数
     * @throws Exception
     */
    public static void execute(final RunHandler runHandler,int executeCount,int concurrentCount) throws Exception {
        ExecutorService executorService = Executors.newCachedThreadPool();
        //控制信号量，此处用于控制并发的线程数
        final Semaphore semaphore = new Semaphore(concurrentCount);
        //闭锁，可实现计数量递减
        final CountDownLatch countDownLatch = new CountDownLatch(executeCount);
        for (int i = 0; i < executeCount; i ++){
            executorService.execute(new Runnable() {
                public void run() {
                    try{
                        //执行此方法用于获取执行许可，当总计未释放的许可数不超过executeCount时,
                        //则允许同性，否则线程阻塞等待，知道获取到许可
                        semaphore.acquire();
                        runHandler.handler();
                        //释放许可
                        semaphore.release();
                    }catch (Exception e){
                        e.printStackTrace();
                    } finally {
                        countDownLatch.countDown();
                    }
                }
            });
        }
        countDownLatch.await();//线程阻塞，知道闭锁值为0时，阻塞才释放，继续往下执行
        executorService.shutdown();
    }
    public interface RunHandler{
        void handler();
    }
}
```



测试类

```java
package com.dml.pattern.singleton.test;


import com.dml.pattern.singleton.register.ContainerSingleton;

public class ContainerSingletonTest {
    public static void main(String[] args) {


        try {
            long start = System.currentTimeMillis();
            ConcurrentExecutor.execute(new ConcurrentExecutor.RunHandler() {
                public void handler() {
                    Object obj = ContainerSingleton.getInstance("com.dml.pattern.singleton.TestObject");
                    System.out.println(System.currentTimeMillis() + ": " + obj);
                }
            }, 10,6);
            long end = System.currentTimeMillis();
            System.out.println("总耗时：" + (end - start) + " ms.");
        } catch (Exception e){
            e.printStackTrace();
        }

    }
}
```



### ThreadLocal(实现多数据源动态切换)

在相同的线程，保证单例。

其实也是注册式单例(容器单例，key是线程，value是实例对象)

```java
package com.dml.pattern.singleton.register;

/**
 * @author dml111727
 * @version 1.0
 * @Date 2021/7/7 0007 21:36
 * @describe
 */
public class ThreadLocalSingleton {

    private static final ThreadLocal<ThreadLocalSingleton> threadLocal = new ThreadLocal<ThreadLocalSingleton>() {
        @Override
        protected ThreadLocalSingleton initialValue() {
            return new ThreadLocalSingleton();
        }
    };

    private ThreadLocalSingleton() {
    }

    public static  ThreadLocalSingleton getInstance() {
        return threadLocal.get();
    }
}

```

###### 测试

线程创建对象

```java
package com.dml.pattern.singleton.test;


import com.dml.pattern.singleton.lazy.LazyMethodLockSingleton;
import com.dml.pattern.singleton.register.ThreadLocalSingleton;


public class ExectorThread implements Runnable{
    @Override
    public void run() {
        ThreadLocalSingleton singleton = ThreadLocalSingleton.getInstance();
        // LazyMethodLockSingleton singleton = LazyMethodLockSingleton.getInstance();
        System.out.println(Thread.currentThread().getName() + ":" + singleton);
    }
}
```



测试

```java
package com.dml.pattern.singleton.test;


import com.dml.pattern.singleton.register.ThreadLocalSingleton;

/**
 * Created by Tom.
 */
public class ThreadLocalSingletonTest {
    public static void main(String[] args) {

        System.out.println(ThreadLocalSingleton.getInstance());
        System.out.println(ThreadLocalSingleton.getInstance());
        System.out.println(ThreadLocalSingleton.getInstance());
        System.out.println(ThreadLocalSingleton.getInstance());
        System.out.println(ThreadLocalSingleton.getInstance());

        Thread t1 = new Thread(new ExectorThread());
        Thread t2 = new Thread(new ExectorThread());
        t1.start();
        t2.start();
        System.out.println("End");

    }
}
```



### 攻击单例

#### 方式一：反射

解决：在私有构造判断，加异常抛出

```java
package com.dml.pattern.singleton.test;

import com.dml.pattern.singleton.lazy.LazyInnerClassSingleton;

import java.lang.reflect.Constructor;


public class LazyInnerClassSingletonTest {

    public static void main(String[] args) {
        try{
            //很无聊的情况下，进行破坏
            Class<?> clazz = LazyInnerClassSingleton.class;

            //通过反射拿到私有的构造方法
            Constructor c = clazz.getDeclaredConstructor(null);
            //强制访问，强吻，不愿意也要吻
            c.setAccessible(true);

            //暴力初始化
            Object o1 = c.newInstance();

            //调用了两次构造方法，相当于new了两次
            //犯了原则性问题，
            Object o2 = c.newInstance();

            System.out.println(o1 == o2);
//            Object o2 = c.newInstance();
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}
```

#### 方式二：序列化

把实例对象写到文件，再重文件读取出来转换成实例对象ObjectInputStream.readObject()

解决：对象加`readResolve`方法

```java
package com.dml.pattern.singleton.test;

import com.dml.pattern.singleton.seriable.SeriableSingleton;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;

public class SeriableSingletonTest {
    public static void main(String[] args) {

        SeriableSingleton s1 = null;
        SeriableSingleton s2 = SeriableSingleton.getInstance();

        FileOutputStream fos = null;
        try {
            fos = new FileOutputStream("SeriableSingleton.obj");
            ObjectOutputStream oos = new ObjectOutputStream(fos);
            oos.writeObject(s2);
            oos.flush();
            oos.close();


            FileInputStream fis = new FileInputStream("SeriableSingleton.obj");
            ObjectInputStream ois = new ObjectInputStream(fis);
            s1 = (SeriableSingleton) ois.readObject();
            ois.close();

            System.out.println(s1);
            System.out.println(s2);
            System.out.println(s1 == s2);

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```



#### 测试序列化单例

```java
package com.dml.pattern.singleton.seriable;

import java.io.Serializable;


//反序列化时导致单例破坏
public class SeriableSingleton implements Serializable {

    //序列化就是说把内存中的状态通过转换成字节码的形式
    //从而转换一个IO流，写入到其他地方(可以是磁盘、网络IO)
    //内存中状态给永久保存下来了

    //反序列化
    //讲已经持久化的字节码内容，转换为IO流
    //通过IO流的读取，进而将读取的内容转换为Java对象
    //在转换过程中会重新创建对象new

    public  final static SeriableSingleton INSTANCE = new SeriableSingleton();
    private SeriableSingleton(){}

    public static SeriableSingleton getInstance(){
        return INSTANCE;
    }

    private  Object readResolve(){
        return  INSTANCE;
    }

}
```

